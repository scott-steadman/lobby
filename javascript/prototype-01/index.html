<html>
  <head>
  </head>
  <body>
    <h1>Connection Prototype</h1>

    <div id="create_request_panel" class="o-panel">
      <button id='create_request_button' onClick="window.controller.createRequest();">Create Connection Request</button>
      <table id='request_table' style="display:none">
        <tr>
          <td>Connection Request:</td>
          <td><input id="connection_request" type="text" disabled/> (copy and send this to host)</td>
        </tr>
     </table>
    </div>

    <hr/>

    <div>
      <span id="accept_request_panel">
        <input id="request_to_accept" type="text"/>
        <button onClick="window.controller.acceptRequest()">Accept Request</button>
      </span>
      <span id="request_response" style="visibility:hidden">
        <input id="response_to_send" type="text" disabled/> (copy and send this to client)<br/>
      </span>
    </div>

    <hr/>

    <div id="accept_response_panel" class="o-panel">
      <span id="accept_response">
        <input id="response_to_accept" type="text"/>
        <button onClick="window.controller.acceptResponse()">Accept Response</button>
      </span>
    </div>

    <hr/>

    <div id="message_panel" class="o-panel">
      <h2>Messages</h2>
      <div>
        <textarea id="messages" rows="10" cols="40" readonly></textarea>
      </div>
      <div>
        <input id="new_message" type="text">
        <button onClick="window.controller.sendMessage();">Send</button>
      </div>
    </div>
  </body>

  <script language='JavaScript'>

    class Connection {

      constructor() {
        const debugEnabled = false;
        const configuration = { iceServers: [{'urls': [
                                                        'stun:stun.l.google.com:19302',
                                                      ]
                                            }],
                              };

        this.peerConnection = new RTCPeerConnection(configuration);

        if(debugEnabled) {
          this.peerConnection.addEventListener('addstream', this.dumpEvent);
          this.peerConnection.addEventListener('connectionstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('datachannel', this.dumpEvent);
          this.peerConnection.addEventListener('icecandidate', this.dumpEvent);
          this.peerConnection.addEventListener('icecandidateerror', this.dumpEvent);
          this.peerConnection.addEventListener('iceconnectionstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('icegatheringstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('negotiationneeded', this.dumpEvent);
          this.peerConnection.addEventListener('removestream', this.dumpEvent);
          this.peerConnection.addEventListener('signalingstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('track', this.dumpEvent);
        }

        // called when a datachannel is added by the other peer
        this.peerConnection.addEventListener('datachannel', (event) => {
          this.channel = event.channel;
        });

        this.channel = this.peerConnection.createDataChannel('connectionChannel', {reliable: true});

        if(debugEnabled) {
          this.channel.addEventListener('bufferedamountlow', this.dumpEvent)
          this.channel.addEventListener('close', this.dumpEvent)
          this.channel.addEventListener('closing', this.dumpEvent)
          this.channel.addEventListener('error', this.dumpEvent)
          this.channel.addEventListener('message', this.dumpEvent)
          this.channel.addEventListener('open', this.dumpEvent)
        }

        this.channel.addEventListener('open', (event) => {
          document.getElementById('messages').value = '**Channel Opened.\n';
        });

        this.channel.addEventListener('closing', (event) => {
          document.getElementById('messages').value += '**Channel Closing...\n';
        });

        this.channel.addEventListener('closed', (event) => {
          document.getElementById('messages').value += '**Channel Closed.\n';
        });
      } // constructor

      dumpEvent(event) {
        console.log('Connection.dumpEvent:', event);
      }

      createRequest(callback) {
        this.peerConnection.createOffer().then((offer) => {
          // wait for the browser to gather all the candidates.
          const handler = (event) => {
                            const newState = event.target.iceGatheringState;
                            console.log('Connection.createRequest iceGatheringState:', newState);
                            switch(newState) {
                              case 'complete':
                                const request = this.peerConnection.localDescription.sdp;
                                console.log('Connection.createRequest request:', request);

                                if(callback) callback(request);

                                this.peerConnection.removeEventListener('icegatheringstatechange', handler);
                                break;
                              default:
                                console.log('Connection.createRequest unhandled iceGatheringState:', newState);
                            }
                          };
          this.peerConnection.addEventListener('icegatheringstatechange', handler);

          this.peerConnection.setLocalDescription(offer);
        });
      }

      acceptRequest(request, callback) {
        console.log('Connection.acceptRequest request:', request);

        this.peerConnection.setRemoteDescription(new RTCSessionDescription({type: 'offer', sdp: request}));
        this.peerConnection.createAnswer().then((answer) => {
          // wait for the browser to gather all the candidates.
          const handler = (event) => {
                            const newState = event.target.iceGatheringState;
                            switch(newState) {
                              case 'complete':
                                const response = this.peerConnection.localDescription.sdp;
                                console.log('Connection.acceptRequest response:', response);

                                if(callback) callback(response);

                                this.peerConnection.removeEventListener('icegatheringstatechange', handler);
                                break;
                              default:
                                console.log('Connection.acceptRequest unhandled iceGatheringState:', newState);
                            }
                          };
          this.peerConnection.addEventListener('icegatheringstatechange', handler);

          this.peerConnection.setLocalDescription(answer);
        });
      }

      acceptResponse(response) {
        console.log('Connection.acceptResponse response:', response);
        this.peerConnection.setRemoteDescription(new RTCSessionDescription({type: 'answer', sdp: response}));
      }

      sendMessage(message) {
        const data = {
          message: message,
          timestamp: new Date().toISOString()
        };
        this.channel.send(JSON.stringify(data));
      }

      onMessage(callback) {
        this.channel.addEventListener('message', (event) => {
          console.log('Connection.onMessage:', event);
          const data = JSON.parse(event.data);
          if(callback) callback(data);
        });
      }

    } // class Connection

    class Controller {

      constructor() {
        this.connection = new Connection();
      }

      start() {
        this.connection.onMessage(this.#onMessage);
        this.createRequest();
      }

      createRequest() {
        this.connection.createRequest(this.#requestCreated);
      }

      acceptRequest() {
        const request = atob(document.getElementById('request_to_accept').value);
        this.connection.acceptRequest(request, this.#requestAccepted);
      }

      acceptResponse() {
        const response = atob(document.getElementById('response_to_accept').value);
        this.connection.acceptResponse(response);
      }

      sendMessage(){
        const message = document.getElementById('new_message').value;
        document.getElementById('new_message').value = '';
        console.debug('sendMessage:', message);
        document.getElementById('messages').value += `Me: ${message}\n`;
        this.connection.sendMessage(message);
      }

    // private functions

      #requestCreated(request) {
        console.debug('Controller.#requestCreated', request);
        document.getElementById('create_request_button').style.display = 'none';
        document.getElementById('request_table').style.display = 'block';
        document.getElementById('connection_request').value = btoa(request);
      }

      #requestAccepted(response) {
        console.debug('Controller.#requestAccepted:', response);
        document.getElementById('request_response').style.visibility = 'visible';
        document.getElementById('response_to_send').value = btoa(response);
      }

      #onMessage(message) {
        console.log('Controller.#onMessage', message);
        document.getElementById('messages').value += `They: ${message.message} ${message.timestamp}\n`;
      }

    } // class Controller

    window.controller = new Controller();
    window.controller.start();

  </script>
</html>