<html>
  <head>
  </head>
  <body>
    <h1>Connection Prototype</h1>

    <div id="create_request_panel">
      <button id='create_request_button' onClick="window.controller.createRequest();">Create Connection Request</button>
      <span id='request_span' style="display:none;">
        Copy join token image and send to host: <img id="connection_request_img"/>
     </table>
    </div>

    <hr/>

    <div>
      <span id="accept_request_panel">
        Paste join token image here: <input id="request_to_accept" size="1" style="border:2px solid black"/>
      </span>
      <span id="request_response" style="visibility:hidden">
        Copy this accept token and send to participant: <img id="response_to_send_img"/>
      </span>
    </div>

    <hr/>

    <div id="accept_response_panel">
      <span id="accept_response">
        Paste accept token image here: <input id="response_to_accept"  size="1" style="border:2px solid black"/>
      </span>
    </div>

    <hr/>

    <div id="message_panel">
      <h2>Messages</h2>
      <div>
        <textarea id="messages" rows="10" cols="40" readonly></textarea>
      </div>
      <div>
        <input id="new_message" type="text">
        <button onClick="window.controller.sendMessage();">Send</button>
        <button onClick="window.controller.sendMessage('Ping');">Ping</button>
        <button onClick="window.controller.sendMessage('Pong');">Pong</button>
      </div>
    </div>
  </body>

  <script language='JavaScript'>

    // stores connetion information in the event of a page reload
    class BrowserConnectionStore {

      constructor() {
        this.store = window.localStorage;
      }

      saveConnection(connection) {
        this.store.setItem('connection', connection.serialize());
      }

      loadConnection() {
return null;
        const payload = this.store.getItem('connection');
        if(payload) {
          return new Connection().deserialize(payload);
        }
        return null;
      }

      deleteConnection() {
        this.store.removeItem('connection');
      }

    } // class BrowserConnectionStore

    // handles the connection between two peers
    class Connection {

      constructor() {
        this.configuration = { iceServers: [{'urls': [
                                                        'stun:stun.l.google.com:19302',
                                                      ]
                                            }],
                              };

        this.protocolVersion = 1;
        this.debugEnabled    = true;
        this.state           = 'new';

        this.#createConnection();
        this.#createDataChannel();
      } // constructor

      #createConnection() {
        this.peerConnection  = new RTCPeerConnection(this.configuration);
        this.iceCandidates   = [];

        if(this.debugEnabled) {
          this.peerConnection.addEventListener('addstream', this.dumpEvent);
          this.peerConnection.addEventListener('connectionstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('datachannel', this.dumpEvent);
          this.peerConnection.addEventListener('icecandidate', this.dumpEvent);
          this.peerConnection.addEventListener('icecandidateerror', this.dumpEvent);
          this.peerConnection.addEventListener('iceconnectionstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('icegatheringstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('negotiationneeded', this.dumpEvent);
          this.peerConnection.addEventListener('removestream', this.dumpEvent);
          this.peerConnection.addEventListener('signalingstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('track', this.dumpEvent);
        }

        // invoked when we or the other peer creates a data channel
        this.peerConnection.addEventListener('datachannel', (event) => {
          console.log('datachannel event:', this.channel.id, event.channel.id, event);

          // We only need one channel.
          if(this.channel.id > event.channel.id) {
            this.channel.close();
            this.channel = event.channel;
            this.#addChannelListeners();
          }
        });
      } // #createConnection

      #createDataChannel() {
        this.channel = this.peerConnection.createDataChannel('connectionChannel', {reliable: true});
        this.#addChannelListeners();
      }

      #addChannelListeners() {
        if(this.debugEnabled) {
          this.channel.addEventListener('bufferedamountlow', this.dumpEvent)
          this.channel.addEventListener('close', this.dumpEvent)
          this.channel.addEventListener('closing', this.dumpEvent)
          this.channel.addEventListener('error', this.dumpEvent)
          this.channel.addEventListener('message', this.dumpEvent)
          this.channel.addEventListener('open', this.dumpEvent)
        }

        this.channel.addEventListener('open', (event) => {
          console.log('channel open:', event.target.id, event);

          switch(this.state) {
            case 'new':
              this.state = 'open';
              if(this.onOpenCallback) this.onOpenCallback(this);
              break;
            case 'closing':
              this.state = 'open';
              if(this.onReconnectCallback) this.onReconnectCallback(this);
              break;
            default:
              console.log('Connection.#addChannelListeners unhandled state:', this.state);
          }
        });

        this.channel.addEventListener('message', (event) => {
          console.log('channel message:', event.target.id, event);
          const data = JSON.parse(event.data);
          if(this.onMessageCallback) this.onMessageCallback(data);
        });

        this.channel.addEventListener('closing', (event) => {
          console.log('channel closing:', event.target.id, event);
          this.state = 'closing';
          if (this.onDisconnectCallback) this.onDisconnectCallback(this);
        });

        this.channel.addEventListener('closed', (event) => {
          console.log('channel closed:', event.target.id, event);
          this.state = 'closed';
          if(this.onConnectionClose) this.onConnectionClose(this);
        });
      }

      dumpEvent(event) {
        console.log('Connection.dumpEvent:', event);
      }

      createRequest() {
        return new Promise((resolve, reject) => {
          this.peerConnection.createOffer().then((offer) => {
            // wait for the browser to gather all the candidates.
            const handler = (event) => {
                              const newState = event.target.iceGatheringState;
                              console.log('Connection.createRequest iceGatheringState:', newState);
                              switch(newState) {
                                case 'complete':
                                  const request = this.peerConnection.localDescription.sdp;
                                  console.log('Connection.createRequest request');
                                  this.peerConnection.removeEventListener('icegatheringstatechange', handler);
                                  resolve({version: this.protocolVersion, request});
                                  break;
                                default:
                                  console.log('Connection.createRequest unhandled iceGatheringState:', newState);
                              }
                            };
            this.peerConnection.addEventListener('icegatheringstatechange', handler);

            this.peerConnection.setLocalDescription(offer);
          });
        })
      }

      acceptRequest(request) {
        console.log('Connection.acceptRequest request');
        this.peerConnection.setRemoteDescription(new RTCSessionDescription({type: 'offer', sdp: request.request}));

        return new Promise((resolve, reject) => {
          this.peerConnection.createAnswer().then((answer) => {
            // wait for the browser to gather all the candidates.
            const handler = (event) => {
                              const newState = event.target.iceGatheringState;
                              switch(newState) {
                                case 'complete':
                                  const response = this.peerConnection.localDescription.sdp;
                                  console.log('Connection.acceptRequest response:', response);
                                  resolve({version: this.protocolVersion, response});
                                  this.peerConnection.removeEventListener('icegatheringstatechange', handler);
                                  break;
                                default:
                                  console.log('Connection.acceptRequest unhandled iceGatheringState:', newState);
                              }
                            };
            this.peerConnection.addEventListener('icegatheringstatechange', handler);

            this.peerConnection.setLocalDescription(answer);
          });
        })
      }

      acceptResponse(response) {
        console.log('Connection.acceptResponse response:', response);
        this.peerConnection.setRemoteDescription(new RTCSessionDescription({type: 'answer', sdp: response.response}));
      }

      sendMessage(message) {
        console.log('Connection.sendMessage:', this.channel.id, message);
        const data = {
          message: message,
          timestamp: new Date().toISOString()
        };
        this.channel.send(JSON.stringify(data));
      }

      serialize() {
        const payload = {
          state:         this.state,
          local:         this.peerConnection.currentLocalDescription,
          remote:        this.peerConnection.currentRemoteDescription,
        };

        console.log('serialize', payload);

        return JSON.stringify(payload);
      }

      deserialize(serialized) {
        const payload = JSON.parse(serialized);
        console.log('deserialize', payload);

        this.state = payload.state;

this.acceptRequest({request: payload.remote.sdp});
return this;
        this.peerConnection.setLocalDescription(payload.local).then(() => {
          console.log('Connection.deserialize setLocalDescription', arguments);
        }).catch((error) => {
          console.log('Connection.deserialize setLocalDescription error', error);
        });
//          this.peerConnection.setLocalDescription(offer);
//          this.peerConnection.setRemoteDescription(new RTCSessionDescription(payload.remote));

        return this;
      }

      /*
       * TODO: See about implementing these callbacks as event listeners
       *
       * Perhaps the following:
       *  addOnOpenCallback(callback)
       *  addEventListener('open', callback)
       *
       */
      addOnOpenCallback(callback) {
        this.onOpenCallback = callback;
      }

      onMessage(callback) {
        this.onMessageCallback = callback;
      }

      onDisconnect(callback) {
        this.onDisconnectCallback = callback;
      }

      onReconnect(callback) {
        this.onReconnectCallback = callback;
      }

      onClose(callback) {
        this.onCloseCallback = callback;
      }

    } // class Connection

    class Utils {

      static encodeToBMP(text) {
          let canvas = document.createElement('canvas');
          let ctx = canvas.getContext('2d');
          let width = Math.ceil(Math.sqrt(text.length));
          let height = Math.ceil(text.length / width);
          canvas.width = width;
          canvas.height = height;
          let imageData = ctx.createImageData(width, height);
          for (let i = 0; i < text.length; i++) {
              let code = text.charCodeAt(i);
              let x = i % width;
              let y = Math.floor(i / width);
              let index = (y * width + x) * 4;
              imageData.data[index] = code >> 8; // High byte
              imageData.data[index + 1] = code & 0xFF; // Low byte
              imageData.data[index + 2] = 0; // Green channel
              imageData.data[index + 3] = 255; // Alpha channel
          }
          ctx.putImageData(imageData, 0, 0);
          return canvas.toDataURL();
      }

      static decodeFromBMP(dataURL) {
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.onload = function() {
                let canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                let imageData = ctx.getImageData(0, 0, img.width, img.height);
                let text = '';
                for (let y = 0; y < img.height; y++) {
                    for (let x = 0; x < img.width; x++) {
                        let index = (y * img.width + x) * 4;
                        let code = (imageData.data[index] << 8) | imageData.data[index + 1];
                        if (code !== 0) { // Ignore padding
                            text += String.fromCharCode(code);
                        }
                    }
                }
                resolve(text);
            };
            img.onerror = reject;
            img.src = dataURL;
        });
      }

    } // class Utils

    class Controller {

      constructor() {
      }

      start() {
        this.#bindElements()
        this.#createConnection();
      }

      #createConnection() {
        const store = new BrowserConnectionStore();

        this.connection = store.loadConnection();
        if(this.connection) {
          console.log('restored connection');
        } else {
          console.log('creating connection');
          this.connection = new Connection();
        }

        this.connection.addOnOpenCallback(this.#onConnectionOpen);
        this.connection.onMessage(this.#onConnectionMessage);
        this.connection.onDisconnect(this.#onConnectionDisconnect);
        this.connection.onReconnect(this.#onConnectionReconnect);
        this.connection.onClose(this.#onConnectionClose);
      }

      #bindElements() {
        this.#bindReqestToAcceptPaste();
        this.#bindResponseToAcceptPaste();
      }

      #bindReqestToAcceptPaste() {
        document.getElementById('request_to_accept').addEventListener('paste', (event) => {
          console.log('request_to_accept paste:', event);

          for(const item of event.clipboardData.items) {
            console.log('item:', item);

            if(item.type.startsWith('image')) {
              const blob = item.getAsFile();
              const reader = new FileReader();
              reader.onload = (event) => {
                Utils.decodeFromBMP(event.target.result).then((text) => {
                  this.acceptRequest(text);
                });
              };
              reader.readAsDataURL(blob);
            }
          }
        });
      }

      #bindResponseToAcceptPaste() {
        document.getElementById('response_to_accept').addEventListener('paste', (event) => {
          console.log('response_to_accept paste:', event);

          for(const item of event.clipboardData.items) {
            console.log('item:', item);

            if(item.type.startsWith('image')) {
              const blob = item.getAsFile();
              const reader = new FileReader();
              reader.onload = (event) => {
                Utils.decodeFromBMP(event.target.result).then((text) => {
                  this.acceptResponse(text);
                });
              };
              reader.readAsDataURL(blob);
            }
          }
        });
      }

      createRequest() {
        this.connection.createRequest().then((request) => {
          console.log('Controller.createRequest');
          document.getElementById('create_request_button').style.display = 'none';
          document.getElementById('request_span').style.display = 'block';
          document.getElementById('connection_request_img').src = Utils.encodeToBMP(JSON.stringify(request));
        });
      }

      acceptRequest(text) {
        const request = JSON.parse(text);
        this.connection.acceptRequest(request).then((response) => {
          console.log('Controller.#requestAccepted');
          document.getElementById('accept_request_panel').style.display = 'none';
          document.getElementById('request_response').style.visibility = 'visible';
          document.getElementById('response_to_send_img').src = Utils.encodeToBMP(JSON.stringify(response));
        });
      }

      acceptResponse(text) {
        const response = JSON.parse(text);
        this.connection.acceptResponse(response);
      }

      sendMessage(message) {
        message = message || document.getElementById('new_message').value;
        document.getElementById('new_message').value = '';
        console.log('Controller.sendMessage:', message);
        document.getElementById('messages').value += `Me: ${message}\n`;
        this.connection.sendMessage(message);
      }

    // private functions

      #onConnectionOpen(connection) {
        console.log('Controller.#onConnectionOpen');
        document.getElementById('messages').value = '**Connection Opened.\n';

        const store = new BrowserConnectionStore();
        store.saveConnection(connection);
      }

      #onConnectionMessage(message) {
        console.log('Controller.#onConnectionMessage', message);
        document.getElementById('messages').value += `They: ${message.message} ${message.timestamp}\n`;
      }

      #onConnectionDisconnect(connection) {
        console.log('Controller.#onConnectionDisconnect');
        document.getElementById('messages').value += '**Connection Disconnected.\n';
      }

      #onConnectionReconnect(connection) {
        console.log('Controller.#onConnectionReconnect');
        document.getElementById('messages').value += '**Connection Reconnected.\n';
      }

      #onConnectionClose(connection) {
        console.log('Controller.#onConnectionClose');
        document.getElementById('messages').value += '**Connection Closed.\n';

        const store = new BrowserConnectionStore();
        store.deleteConnection();
      }

    } // class Controller

    window.controller = new Controller();
    window.controller.start();

  </script>
</html>
