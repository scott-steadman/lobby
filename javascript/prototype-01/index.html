<html>
  <head>
  </head>
  <body>
    <h1>Connection Prototype</h1>

    <div id="create_request_panel">
      <button id='create_request_button' onClick="window.controller.createRequest();">Create Connection Request</button>
      <span id='request_span' style="display:none;">
        Copy join token image and send to host: <img id="connection_request_img"/>
     </table>
    </div>

    <hr/>

    <div>
      <span id="accept_request_panel">
        Paste join token image here: <input id="request_to_accept" size="1" style="border:2px solid black"/>
      </span>
      <span id="request_response" style="visibility:hidden">
        Copy this accept token and send to participant: <img id="response_to_send_img"/>
      </span>
    </div>

    <hr/>

    <div id="accept_response_panel">
      <span id="accept_response">
        Paste accept token image here: <input id="response_to_accept"  size="1" style="border:2px solid black"/>
      </span>
    </div>

    <hr/>

    <div id="message_panel">
      <h2>Messages</h2>
      <div>
        <textarea id="messages" rows="10" cols="40" readonly></textarea>
      </div>
      <div>
        <input id="new_message" type="text">
        <button onClick="window.controller.sendMessage();">Send</button>
      </div>
    </div>
  </body>

  <script language='JavaScript'>

    class Connection {

      constructor() {
        const debugEnabled = false;
        const configuration = { iceServers: [{'urls': [
                                                        'stun:stun.l.google.com:19302',
                                                      ]
                                            }],
                              };

        this.protocolVersion = 1;
        this.peerConnection = new RTCPeerConnection(configuration);

        if(debugEnabled) {
          this.peerConnection.addEventListener('addstream', this.dumpEvent);
          this.peerConnection.addEventListener('connectionstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('datachannel', this.dumpEvent);
          this.peerConnection.addEventListener('icecandidate', this.dumpEvent);
          this.peerConnection.addEventListener('icecandidateerror', this.dumpEvent);
          this.peerConnection.addEventListener('iceconnectionstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('icegatheringstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('negotiationneeded', this.dumpEvent);
          this.peerConnection.addEventListener('removestream', this.dumpEvent);
          this.peerConnection.addEventListener('signalingstatechange', this.dumpEvent);
          this.peerConnection.addEventListener('track', this.dumpEvent);
        }

        // called when a datachannel is added by the other peer
        this.peerConnection.addEventListener('datachannel', (event) => {
          this.channel = event.channel;
        });

        this.channel = this.peerConnection.createDataChannel('connectionChannel', {reliable: true});

        if(debugEnabled) {
          this.channel.addEventListener('bufferedamountlow', this.dumpEvent)
          this.channel.addEventListener('close', this.dumpEvent)
          this.channel.addEventListener('closing', this.dumpEvent)
          this.channel.addEventListener('error', this.dumpEvent)
          this.channel.addEventListener('message', this.dumpEvent)
          this.channel.addEventListener('open', this.dumpEvent)
        }

        this.channel.addEventListener('open', (event) => {
          document.getElementById('messages').value = '**Channel Opened.\n';
        });

        this.channel.addEventListener('closing', (event) => {
          document.getElementById('messages').value += '**Channel Closing...\n';
        });

        this.channel.addEventListener('closed', (event) => {
          document.getElementById('messages').value += '**Channel Closed.\n';
        });
      } // constructor

      dumpEvent(event) {
        console.log('Connection.dumpEvent:', event);
      }

      createRequest(callback) {
        this.peerConnection.createOffer().then((offer) => {
          // wait for the browser to gather all the candidates.
          const handler = (event) => {
                            const newState = event.target.iceGatheringState;
                            console.log('Connection.createRequest iceGatheringState:', newState);
                            switch(newState) {
                              case 'complete':
                                const request = this.peerConnection.localDescription.sdp;
                                console.log('Connection.createRequest request:', request);

                                if(callback) callback({version: this.protocolVersion, request});

                                this.peerConnection.removeEventListener('icegatheringstatechange', handler);
                                break;
                              default:
                                console.log('Connection.createRequest unhandled iceGatheringState:', newState);
                            }
                          };
          this.peerConnection.addEventListener('icegatheringstatechange', handler);

          this.peerConnection.setLocalDescription(offer);
        });
      }

      acceptRequest(request, callback) {
        console.log('Connection.acceptRequest request:', request);

        this.peerConnection.setRemoteDescription(new RTCSessionDescription({type: 'offer', sdp: request.request}));
        this.peerConnection.createAnswer().then((answer) => {
          // wait for the browser to gather all the candidates.
          const handler = (event) => {
                            const newState = event.target.iceGatheringState;
                            switch(newState) {
                              case 'complete':
                                const response = this.peerConnection.localDescription.sdp;
                                console.log('Connection.acceptRequest response:', response);

                                if(callback) callback({version: this.protocolVersion, response});

                                this.peerConnection.removeEventListener('icegatheringstatechange', handler);
                                break;
                              default:
                                console.log('Connection.acceptRequest unhandled iceGatheringState:', newState);
                            }
                          };
          this.peerConnection.addEventListener('icegatheringstatechange', handler);

          this.peerConnection.setLocalDescription(answer);
        });
      }

      acceptResponse(response) {
        console.log('Connection.acceptResponse response:', response);
        this.peerConnection.setRemoteDescription(new RTCSessionDescription({type: 'answer', sdp: response.response}));
      }

      sendMessage(message) {
        const data = {
          message: message,
          timestamp: new Date().toISOString()
        };
        this.channel.send(JSON.stringify(data));
      }

      onMessage(callback) {
        this.channel.addEventListener('message', (event) => {
          console.log('Connection.onMessage:', event);
          const data = JSON.parse(event.data);
          if(callback) callback(data);
        });
      }

    } // class Connection

    class Utils {

      static encodeToBMP(text) {
          let canvas = document.createElement('canvas');
          let ctx = canvas.getContext('2d');
          let width = Math.ceil(Math.sqrt(text.length));
          let height = Math.ceil(text.length / width);
          canvas.width = width;
          canvas.height = height;
          let imageData = ctx.createImageData(width, height);
          for (let i = 0; i < text.length; i++) {
              let code = text.charCodeAt(i);
              let x = i % width;
              let y = Math.floor(i / width);
              let index = (y * width + x) * 4;
              imageData.data[index] = code >> 8; // High byte
              imageData.data[index + 1] = code & 0xFF; // Low byte
              imageData.data[index + 2] = 0; // Green channel
              imageData.data[index + 3] = 255; // Alpha channel
          }
          ctx.putImageData(imageData, 0, 0);
          return canvas.toDataURL();
      }

      static decodeFromBMP(dataURL) {
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.onload = function() {
                let canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');
                canvas.width = img.width;
                canvas.height = img.height;
                ctx.drawImage(img, 0, 0);
                let imageData = ctx.getImageData(0, 0, img.width, img.height);
                let text = '';
                for (let y = 0; y < img.height; y++) {
                    for (let x = 0; x < img.width; x++) {
                        let index = (y * img.width + x) * 4;
                        let code = (imageData.data[index] << 8) | imageData.data[index + 1];
                        if (code !== 0) { // Ignore padding
                            text += String.fromCharCode(code);
                        }
                    }
                }
                resolve(text);
            };
            img.onerror = reject;
            img.src = dataURL;
        });
      }

    } // class Utils

    class Controller {

      constructor() {
        this.connection = new Connection();
      }

      start() {
        this.#bindElements()
        this.connection.onMessage(this.#onMessage);
        this.createRequest();
      }

      #bindElements() {
        this.#bindReqestToAcceptPaste();
        this.#bindResponseToAcceptPaste();
      }

      #bindReqestToAcceptPaste() {
        document.getElementById('request_to_accept').addEventListener('paste', (event) => {
          console.log('request_to_accept paste:', event);

          for(const item of event.clipboardData.items) {
            console.log('item:', item);

            if(item.type.startsWith('image')) {
              const blob = item.getAsFile();
              const reader = new FileReader();
              reader.onload = (event) => {
                Utils.decodeFromBMP(event.target.result).then((text) => {
                  this.acceptRequest(text);
                });
              };
              reader.readAsDataURL(blob);
            }
          }
        });
      }

      #bindResponseToAcceptPaste() {
        document.getElementById('response_to_accept').addEventListener('paste', (event) => {
          console.log('response_to_accept paste:', event);

          for(const item of event.clipboardData.items) {
            console.log('item:', item);

            if(item.type.startsWith('image')) {
              const blob = item.getAsFile();
              const reader = new FileReader();
              reader.onload = (event) => {
                Utils.decodeFromBMP(event.target.result).then((text) => {
                  this.acceptResponse(text);
                });
              };
              reader.readAsDataURL(blob);
            }
          }
        });
      }

      createRequest() {
        this.connection.createRequest(this.#requestCreated.bind(this));
      }

      acceptRequest(text) {
        const request = JSON.parse(text);
        this.connection.acceptRequest(request, this.#requestAccepted);
      }

      acceptResponse(text) {
        const response = JSON.parse(text);
        this.connection.acceptResponse(response);
      }

      sendMessage(){
        const message = document.getElementById('new_message').value;
        document.getElementById('new_message').value = '';
        console.debug('sendMessage:', message);
        document.getElementById('messages').value += `Me: ${message}\n`;
        this.connection.sendMessage(message);
      }

    // private functions

      #requestCreated(request) {
        console.debug('Controller.#requestCreated', request);
        document.getElementById('create_request_button').style.display = 'none';
        document.getElementById('request_span').style.display = 'block';
        document.getElementById('connection_request_img').src = Utils.encodeToBMP(JSON.stringify(request));
      }

      #requestAccepted(response) {
        console.debug('Controller.#requestAccepted:', response);
        document.getElementById('accept_request_panel').style.display = 'none';
        document.getElementById('request_response').style.visibility = 'visible';
        document.getElementById('response_to_send_img').src = Utils.encodeToBMP(JSON.stringify(response));
      }

      #onMessage(message) {
        console.log('Controller.#onMessage', message);
        document.getElementById('messages').value += `They: ${message.message} ${message.timestamp}\n`;
      }

    } // class Controller

    window.controller = new Controller();
    window.controller.start();

  </script>
</html>